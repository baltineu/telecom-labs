# STP 

STP необходим для резервации линков. Без STP есть три проблемы, с которыми мы сталкиваемся, если создаём «треугольник» или ещё какой-то граф с циклами из свитчей:

1) Широковещательный шторм (свитчи будут переотправлять друг другу и множить широковещалки)
1) Множественные копии пакетов (один и тот же пакет пойдёт по двум и более путям (если mac – широковещалка) и придёт несколько раз)
1) Нестабильность таблицы коммутации (пришедший на два интерфейса от одного и того же мака пакет вынудит свитч изменить таблицу коммутации).

STP решает эти проблемы построением дерева и отключением (резервацией) некоторых маршрутов.

STP – spanning-tree protocol – протокол связующего дерева.

Построение дерева начинается с выбора корня. Корневым (root bridge – корневой мост) становится свитч с наименьшим значением приоритета (по умолчанию 32768). Если у всех свитчей одинаковый приоритет, выбирается свитч с наименьшим мак-адресом. 

На каждом не-корневом свитче выбирается корневой порт (root port) (порт, предоставляющий минимальную стоимость пути от свитча, которому принадлежит порт, до корневого свитча – учитывается и скорость линков, и количество хопов). 

Ещё выбираются назначенные порты (designated port) – один на сегмент. Этот порт предоставляет минимальную стоимость пути до RB от сегмента (в простейшем случае все сегменты у нас point-to-point). 

В конце, если у нас остаётся один сегмент, один из портов будет назначенным, а другой заблокированным. Назначенным станет порт свитча с меньшим приоритетом, либо, если приоритеты равны, с наименьшим маком. 

Краткий алгоритм:

1) Выбор корневого моста
1) Выбор корневых портов
1) Выбор назначенных портов
1) Блокировка оставшихся портов. 

Для обычного STP порт проходит 4 состояния: (50 секунд)

1) Сначала все порты в Blocking, который длится 20 секунд
1) Listening – пересылаются только служебные данные, 15 секунд
1) Learning – 15 секунд
1) Forwarding – передача
# Rapid STP

Просто заменили Blocking + Listening = Discarding (отбрасывание), которое теперь в сумме длится 15 секунд. (30 секунд всё вместе). 

Изменились и типы портов: port fast – на нём не может возникнуть петля (подключен к конечному устройству), поэтому он не участвует в построении дерева; backup port – дублер назначенного порта, alternate port – дублер корневого порта.
# Per VLAN RSTP

Вариант для балансировки трафика. 
# Cert. guide

С. 218 – Bridge ID и Hello BPDU

BID состоит из 2 байт приоритета и 6 байт system ID (используется MAC-адрес).

BPDU – bridge prot. data units содержит информацию:

1) О том, кого отправитель считает корневым свитчом
1) Какой у отправителя BID
1) Какова цена пути до корня от отправителя
1) Таймеры (?)

## Выбор корневого моста (c.219)
Построение дерева начинается с выбора корня. Корневым (root bridge – корневой мост) становится свитч с наименьшим значением приоритета (по умолчанию 32768). Если у всех свитчей одинаковый приоритет, выбирается свитч с наименьшим мак-адресом. (Приоритет и System ID входят в один BID, передающийся по BPDU)

Процесс выбора происходит при помощи передачи Hello BPDU. Сначала все мосты отправляют BPDU со своим BID в качестве Root bridge ID. Затем, если они получили BPDU с меньшим, чем у них, root BID, они начинают рассылать BPDU именно с этим root BID. 

В итоге остаётся один root bridge.
## Выбор корневых портов (c.220)
На каждом не-корневом свитче выбирается корневой порт (root port) (порт, предоставляющий минимальную стоимость пути от свитча, которому принадлежит порт, до корневого свитча – учитывается и скорость линков, и количество хопов – least root cost). 

В каждом BPDU свитч, его отправивший, указывает root cost – стоимость пути до корневого моста. Root cost – это и стоимость root port, так как путь до RB пролегает именно через него. 

As humans, мы складываем стоимости портов, из которых должен *выйти* кадр, проходя путь. В качестве root port выбирается порт, из которого путь меньше по стоимости. 

Мосты узнают стоимости из сообщений и выбирают свой root port.

Port cost – целое число, привязанное к конкретному интерфейсу для конкретного vlan.

1) RB sends Hellos with root costs 0
1) Sw2, Sw3 add this 0 to their ports’ costs
1) Sw2 sends to Sw3 Hello with root cost = 4
1) Sw3 adds this 4 to Gi0/2 port cost
1) Sw3 decides that Gi0/1 is a root port.

Если где-то получаются равные стоимости, то:

(это если два интерфейса свитча в один collision domain включены через хаб)
## Выбор назначенных портов (c.222)
Designated портом в каждому сегменте становится порт того свитча, у которого минимальная root cost. Если root cost совпадают, выбирается свитч с минимальным BID.

Все DP переходят в forwarding state.

## Остальные порты блочатся (c.223)
Порты, ведущие до конечных устройств становятся designated, поскольку конечные устройства не говорят свой root cost и не дают портам свитча стать root; зато порты свитча выигрывают в designated по той же причине.
## Настройка топологии STP (c.223)
Можно влиять на приоритет (BID) устройства и на port costs.

Важно: на cost влияет не макс. скорость, а действующая (минимальная скорость из портов в сегменте).

Важно: можно использовать значения из более поздних стандартов:

Spanning-tree pathcost method long
## Детали, касающиеся STP/RSTP и прочего (c.224)

Отложено, так как не работают VLAN’ы и я не могу нормально настраивать уже имеющуюся топологию.
